% LaTeX template for MICS papers
% To Run:  pdflatex Sample.tex

\documentclass[12pt]{article}

\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\topmargin}{0in}
\setlength{\headheight}{0in}
\setlength{\headsep}{0in}
\setlength{\textwidth}{6in}
\setlength{\textheight}{9in}
\setlength{\parindent}{0in} 

\usepackage{graphicx} %For jpg figure inclusion
\usepackage{times} %For typeface
\usepackage{epsfig}
\usepackage{color} %For Comments
\usepackage[all]{xy}
\usepackage{float}
\usepackage{subfigure}
\usepackage{url}

\input{macros}

% Types
\newtype{\jlstring}{java.lang.String}
\newtype{\jlnum}{java.lang.Number}
\newtype{\jllong}{java.lang.Long}
\newtype{\jlchar}{java.lang.Character}
\newtype{\clifn}{clojure.lang.IFn}
\newtype{\clipm}{clojure.lang.IPersistentMap}
\newtype{\clkeyword}{clojure.lang.Keyword}
\newtype{\clpam}{clojure.lang.PersistentArrayMap}
\newtype{\clpv}{clojure.lang.PersistentVector}
\newtype{\cce}{ClassCastException}
\newtype{\iae}{IllegalArgumentException}
\newtype{\ioobe}{IndexOutOfBoundsException}

\begin{document}
\pagestyle{plain}

\title{Improving Error Messages in the Clojure Programming Language}

\author{
Brian Goslinga, Eugene Butler, Elena Machkasova (adviser)\\
Computer Science Discipline \\
University of Minnesota Morris\\
Morris MN, 56267\\
gosli008@umn.edu, butle250@umn.edu, elenam@umn.edu
}

\date{}

\maketitle
\thispagestyle{empty}

\begin{abstract}
Clojure is a promising language for all levels of practical and instructional computer science. Its clean implementation of concurrent features and its performance-aware language implementation make it a promising language for software development. Unfortunately, Clojure's often confusing error reporting acts as a major confounding factor to its practical and educational use 
and may complicate attempts to both teach and meaningfully employ the language. This paper explores how the error messages produced by Clojure can be improved and describes work done towards this goal.
%\emcomment{This is focusing on instruction only, but Clojure isn't even used in CSCi education. The claims are our own entirely and placing them in the abstract gives the wrong impression about the paper. Shift the emphasis to industry}
\end{abstract}

\newpage
\setcounter{page}{1}



\section{Introduction}
Error message efficacy is an important, though often overlooked, consideration
when tackling the problems of modern software engineering. Error messages that
are difficult to understand and therefore difficult to resolve are daunting for
experienced and novice programmers alike~\cite{traver:messages}. The Clojure programming language's error messages represent perfect examples of this phenomenon.

In this paper, we first present a few basic principles for clear, understandable error reporting. Next, we examine Clojure's current error messages and
examine the factors that lead to their inability to clearly report relevant information. We then present improved
versions of the original error messages, versions that better follow our basic
principles. Finally, we present opportunities for future work and deliver our conclusions.

\subsection{Related work}
We have found that scholarly work on the usability of error messages is noticeably
lacking. During our search for work regarding systematic approaches to
error message quality evaluation, we only found \cite{traver:messages}.

In \cite{traver:messages}, Traver suggests 
%\ebcomment{should this be in past-tense?} 
%\emcomment{present tense is preferred}
two general approaches to the problem
of unhelpful error messages. Programmer-driven approaches to error improvement
involve each programmer creating their own sets of error messages and solutions
based on past, personal experience. Compiler-driven approaches involve improving
the error reporting of the compiler itself, whether these improvements take the
form of improved stack traces or next-generation affective computing. While our approach involves the use of programmer feedback, it is focused on improving compiler-generated error reporting. 
%\emcomment{I don't think we do what Traver calls programmer-derived since that approach allows every porgrammer to create their own set of error messages. We should also mention that Traver proposes requirements for quality of error messages that we used as a guide for developing our basic principles.}

\cite{acm:fortify} is also of relevance to our work, providing  
an example of a language improvement done with error messages quality in mind.  
%, but in a different way. 
Its description of the \code{syntax-parse} macro definition facility in the
Racket programming language outlines a radical, new concept for error reporting. The \code{syntax-parse} system's error reporting is informed by the idea that messages generated by the system should be based on documented concepts rather than, as is true of conventional error reporting, implementation details. By doing so, \cite{acm:fortify} is able to provide clearer and more useful error output to the programmer.

\section{Background}
\subsection{Overview of Clojure}
\label{subsec:overview}
Clojure is a relatively young programming language first introduced in
2007. It is a dynamically-typed functional language in the Lisp family and was designed with an emphasis on support for
concurrent programming. Clojure provides literal syntax for multiple collection types, including lists, vectors, maps, and sets (see Figure~\ref{fig:syntax}).  Lists are collections that directly implement Clojure's sequence interface.  Vectors are indexed collections one can retrieve items from by providing integer indices. Sets are collections, but only of unique items. Maps are collections of keys linked (mapped) to values. Keywords, indicated by the \code{:} prefix, are simple symbolic identifiers that always evaluate to themselves. They are used as unique tokens to be passed around in a program or to label other elements.
%\emcomment{I added this to definition of a keyword (and a word "simple" in the previous sentence)}
%\ebcomment{are symbolic identifiers that always evaluate to themselves. (I cannot think of a way to rephrase this to not be in the exact words of the Clojure documentation without losing precision or effectiveness.)}
% \emcomment{Need to explain the syntax in the figure, in particular :. Also need to say at least something about semantics of each type}
Clojure makes full use of its richer syntax, resulting in better syntactic delimitation than most other Lisp dialects (see Figure~\ref{fig:source}). \code{fn} is the syntax for creating an anonymous function, parentheses delimit the function definition, and square brackets indicate function parameters. \code{assoc} associates one or more keys in a map to values and \code{reduce} returns the result of applying an operation to every element in a collection. This code creates a map in which the keys are each unique item in a collection and the values linked to each key are the number of times each item appears within the collection.
%\emcomment{"fn" is  a syntax for an anonymous function, parentheses delimit the function definition, square brackets indicate function parameters; also explain assoc and reduce}
%\emcomment{A couple of sentences of explanation of what this code does}

\begin{figure}
\begin{center}
\begin{tabular}{|c|c|}
\hline
\textbf{Type} & \textbf{Syntax} \\ \hline
List & \code{(1 2 :keyword "string")} \\ \hline
Vector & \code{[3 7 :foo "bar"]} \\ \hline
Set & \code{\#\{:dog :cat\}} \\ \hline
Map & \code{\{:cat "cute", :dog "loud"\}} \\ \hline
\end{tabular}
\caption{Literal collection syntax in Clojure}
\label{fig:syntax}
\end{center}
\end{figure}

\begin{figure}
\raggedright
\code{(defn frequencies}\\
\code{~~"Returns a map from distinct items in coll to the number}\\
\code{~~of times they appear."}\\
\code{~~[coll]}\\
\code{~~(reduce (fn [counts x]}\\
\code{~~~~~~~~~~~~(assoc counts x (inc (get counts x 0))))}\\
\code{~~~~~~~~~~\{\}}\\
\code{~~~~~~~~~~coll))}
\caption{Example of Clojure source code}
\label{fig:source}
\end{figure}

All of Clojure's built-in collection types are persistent data structures.
This means that they are immutable, so they cannot be modified ``in place'', 
but have fast ``updating'' operations that do
not degrade the performance of either the old or the new version. This is done through
structural sharing of the majority of the old and new versions of the data
structure. Clojure's lists are
implemented like Lisp's traditional lists. Clojure's vectors, maps, and sets are
built out of 32-way trees, allowing for fast access.

Clojure is built around a sequence abstraction, and all of the built-in
collection can be easily turned into a sequence. Clojure also features lazy
sequences. This makes the many practical advantages of lazy evaluation available within a strictly evaluated language. Many of Clojure's built-in
functions act on sequences (and will coerce their appropriate arguments into
sequences) and return lazy sequences.

Clojure handles mutable state by introducing reference types. These types point to an
object and can be updated to point to a new object. All update operations on
reference types have concurrency semantics, and there are a number of reference
types for different concurrency semantics. The \code{ref} reference type makes
updates by using software transactional memory, the \code{atom} reference type
makes updates using compare-and-set, the \code{var} reference type stores its
value using thread-local storage, and the \code{agent} reference type uses
asynchronously queued updates.

\begin{figure}
\raggedright
\code{(import '[javax.swing JFrame JLabel])}\\
\code{(doto (JFrame.~"Example")}\\
\code{~~(.add (JLabel.~"Hello, world!"))}\\
\code{~~.pack}\\
\code{~~.show)}
\caption{An example of Java interop in Clojure}
\label{fig:interop}
\end{figure}

Clojure is also designed to be hosted on a platform. The main
implementation is hosted on the Java Virtual Machine (JVM). Because the
JVM-based Clojure is the ``official'' version, we shall assume the use of that version in
this paper. Clojure uses Java types when appropriate (for instance,
strings in Clojure are \jlstring s). Clojure also provides several interop forms
to make working with and using Java code easy (see Figure~\ref{fig:interop} for
an example). Clojure allows the programmer to easily make use of Java Swing classes to create a window and text label populated with the text "Hello World!".
%\emcomment{once again, a couple of sentences explaining the example}
Clojure is also designed with
performance in mind, and provides several functions for accessing host features
such as arrays for fast code. As a result of Clojure's hosted nature and commitment to
speed, several host features make themselves visible in the
language. Java's lack of tail-call optimization means that Clojure does not
provide tail-call optimization. As a workaround, Clojure provides the
\code{loop} and \code{recur} special forms for optimized self-recursion \cite{halloway:clojure}. As of
Clojure 1.3\footnote{Clojure 1.3 has not been released as of the writing of this paper}, Clojure uses
primitive long math with bigint contagion. Clojure performs overflow checks by
default and will throw an exception if overflow occurs.
%\emcomment{need to explain}
%\emcomment{Need a reference to a clojure book or documentation for
%  this section}
%\bgcomment{I can't think of a good reference for this stuff; Programming Clojure
%  might work for loop/recur, but not for the stuff past 1.0}

Clojure uses immutable data structures by default. Its clean 
implementation of concurrent features and its performance-aware 
language implementation make it a promising language for software
development. Despite being a new language, Clojure has generated 
significant attention in industry, as suggested by anecdotal evidence regarding the rise in questions
about Clojure at job interviews. 
%\ebcomment{do we have a source for this?}
%\emcomment{as anecdotal evidence suggests}
Furthermore, Clojure may also be an attractive alternative
to Scheme/Racket for introductory courses due to its richer syntax, and
ability to allow for smoother transitions to later Java-based courses. 
%\ebcomment{also this}
%\emcomment{This is an opinion (we say "may be"). No need to justify.}
%\ebcomment{this half-paragraph is just sort of floating out here and I don't know what to do with it.}
%\emcomment{Added to it, is it better now?}


\subsection{Issues with Clojure error messages}
As a result of Clojure's hosted nature, Clojure's error messages are presented
using the host's underlying mechanism (exceptions), with type errors being
presented using the corresponding concept on the host (\cce). This reliance on
the host is extremely problematic, as it makes Clojure's current error messages less intelligible within the context of one's Clojure instructions. The error
messages frequently expose implementation details when these details are not
relevant. This tends to cause further confusion about the reported error rather than
enlightenment. An example of this form of suboptimal error presentation is found in the stacktrace presented in \cite{goncalves:clojure}. The stack trace provides copious implementation detail, but is of almost no use in explaining the programmer's error.

In addition to the potentially confounding interactions created by the hosted nature of Clojure, Clojure's
error messages are flawed in two other important ways. First, Clojure's error messages, in some circumstances, do not yet
yield enough information about the problem to aid successful debugging. Second,
the error messages occasionally do not respect the abstraction that the user is
using and, instead, refer to less relevant implementation details.

The current messages for several errors can be found in the table in
appendix~\ref{app:exceptions}.

\section{Improving error messages}
After examining various error messages and their possible improvements, we
discovered that Clojure error messages could be approximately classified into one of
three groups: those caused by type casts, those caused by invalid arguments, and those dependent on context.

In section~\ref{subsec:typecast} we describe the issues with the current error
messages caused by type errors, and how we improve these error
messages. 
In section~\ref{subsec:invalid-args} we look at the issues presented by
the larger class of error messages caused by invalid arguments (this excludes
those caused by type errors), and propose ways to improve these error 
messages. Finally, in section~\ref{subsec:context-dep} we examine the issues
and hard problems faced when trying to improve very context-dependent error
messages, and present possible solutions and
their trade-offs.

For examples and classification of several error messages,
see the table in the appendix~\ref{app:exceptions}. The error messages in the
table are referred to by number throughout the course of this paper.

\subsection{Basic principles}
Our improved error messages are designed around several basic principles.
Adherence to sound, basic principles helps to ensure that our improved error
messages are consistent and predictable. Our basic principles are designed
around a controlled exposure to implementation details, and quality of
implementation.

We feel that many of current error messages in Clojure solely display
implementation details. This has the effect of making error messages
confusing for many newcomers, as understanding these error messages requires
that one understands the implementation details of the language. At the same time, hiding all of
the implementation details would make it harder for newcomers to learn about the
implementation of Clojure, and would cause frustration during the rare occasions
that knowing implementation details would be helpful.

Our basic principles address the above concerns. Our improvements to Clojure's error 
reporting should make the new error messages understandable even to those without a 
developed understanding of the language's implementation details. At the same time, the new
error messages should present the implementation details so that the error
messages are useful when details are needed, so new Clojure programmers
can gradually learn about the implementation details, if they so desire.

Given our approach to improving the error messages, there are several
possible ways 
to implement the improvements. Each of which comes with various
trade-offs. As mentioned in 
subsection~\ref{subsec:overview}, Clojure has a strong commitment to
performance. Given that errors should be exceptional, it would be very
unfortunate to penalize correct code with a runtime cost for better error
reporting. We should thus strive to avoid increasing the runtime cost of
operations if possible, and increase the costs minimally otherwise. At the same
time, we also wish to make minimal changes to the implementation of
Clojure. This is based on the assumption that the less code we have to change,
the easier it would be for our work to be integrated and used.
%\ebcomment{how much of this is supposed to be in past tense and how much in present?}
To satisfy these constraints on our implementation, our primary method of
improving Clojure's error reporting is to change how the thrown exception is displayed
to the programmer. This means that we only have the original error message
and a stack trace to work with, but this also means that we do not need to
change the implementation of Clojure (and thus possibly add additional
runtime cost) in a majority of cases. We therefore design our improved error messages
so that, in the majority of cases, they can be produced using only the original
error message and the stack trace.

\subsection{Clarifying type cast exceptions}\label{subsec:typecast}
One of the most common error messages in Clojure is the \cce~error
message. These messages are generated by the JVM when the user attempts to cast
an object to an incompatible class. Due to the number of them that occur, we
distinguish these error messages from invalid argument exceptions. See
appendix~\ref{app:exceptions} for a listing of error messages of this type.

A fairly typical example of such an error message is error
message~\ref{adding-maps}  (see Appendix~\ref{app:exceptions}). In
this error message, the troublesome code is 
\codeblock{(+ \{:a 1, :b 2\} 3)}
The current  error message that this code snippet results in is
\codeblock{ClassCastException clojure.lang.PersistentArrayMap cannot be cast to
  java.lang.Number}

There are several issues with this error message. First, the ``cannot be cast to''
language in the error message does not make sense in the context of Clojure as the programmer
does not make explicit casts. Second, although the actual
type names are useful to know, this error message does not give much indication
as to what entities these type names correspond to.

To address the first issue, ``Cannot use \ldots as \ldots'' language would be
more appropriate for Clojure. Switching the previous error message to this
form yields:
\codeblock{ClassCastException Cannot use clojure.lang.PersistentArrayMap as a
  java.lang.Number}

To address the second issue, we add an informal, intuitive description of the
type name that we term \emph{fuzzy types} to the actual type name to yield the
final error message:
\codeblock{ClassCastException Cannot use a map (clojure.lang.PersistentArrayMap)
  as a number (java.lang.Number)}

The main problem one faces when implementing fuzzy types is the problem of determining
what the fuzzy type for an arbitrary class should be. Our solution is to look at
the class/interfaces that a class extends/implements. These are then compared
against a fixed list of class/interface to fuzzy type mappings. If there is only
one match, the decision is simple. However, there might be multiple matches. For
example, because a Clojure vector can be used as a function (from index to
value), it implements both the
\code{clojure.lang.IPersistentVector} 
interface and the \code{clojure.lang.IFn} interface. In cases like this, there
is usually only one appropriate fuzzy type. To decide which fuzzy type to
report, we define a partial order on the classes/interfaces to determine the
most relevant fuzzy type. If no fuzzy type name can be generated, we fall back
to giving just the class name in the error message.

Occasionally, a class name is the class name of a named function. If we detect
that this is the case, we provide the namespaced-name of the function in place
of the class name in the resulting error message.

\subsection{Clarifying invalid arguments}\label{subsec:invalid-args}
The problems with Clojure's reporting of type cast errors were universally mitigable with a relatively simple fix. Unfortunately, issues with error reporting resulting from invalid arguments are not as simply soluble. We must handle multiple exception types, and the
current error messages do not always provide enough information to improve the
error messages.

As an example, consider the code that causes the error message~\ref{bad-index}:
\codeblock{(nth [1 2 3 4] 6)}
\code{nth} returns the $\mbox{n}^{\mbox{\footnotesize{th}}}$ element of some collection. If the
index is not in the bounds then \code{nth} throws an
\ioobe.
The exception is thrown, but there
is no message with the exception, so the message Clojure displays is
\codeblock{\ioobe}
This is not a lot to work with. It would be desirable to have a message
similar to the one that the Java Collections classes throw, such as
\code{ArrayList}. We thus want the error message that Clojure throws to be
\codeblock{\ioobe~Index: 6, Size: 4}

To implement this change, we had to modify Clojure's source code in several
locations so that \code{nth} would throw the appropriate error message. This did
not impose a significant runtime cost as we only added 
%\ebcomment{now we switch back to present-tense for some reason. What
%do I do here?} 
a counter to determine the
length of a collection if the collection's length cannot be found in constant
time.

Fixing the error message is simple if the index given to \code{nth} is
non-negative, as we either know the length of the collection upfront or we find
the length by running out of the collection. When the index is negative, things
are more difficult. For the collections that come with Clojure, such an index is
always invalid. However, since Clojure supports infinite sequences, we might not
always be able to find the length of the collection. Therefore, we report
``unknown'' as the length of the collection if the length of the collection
cannot be determined in constant time. An example of such an error message is
error message~\ref{neg-index-infinite}.

Other error message of this type can be found in Appendix~\ref{app:exceptions}.

\subsection{Context-dependent Java exceptions}
\label{subsec:context-dep}
Some error messages are hard to improve upon because they come from deep inside a
function's implementation. We currently do not have a solution for this class of
error messages. We instead describe the issues that surround these types of
error messages 
%below 
and discuss the trade-offs of different approaches.

As an example of a context-dependent error message, consider error
message~\ref{into-conj}. The code that generates the error message is
\codeblock{(into \{\} (range 10))}
This code fragment is trying to add the integers 0-9 to an empty map. This
operation generates an error as an integer is not a valid form of a map
entry, nor can an integer be treated as a sequence of map entries. The error
message that this code currently generates is
\codeblock{\iae~Don't know how to create \code{ISeq} from: \jllong}

%\ebcomment{I think "Lets trace the cause of the exception." can be
%edited out.} 
The call to \code{into} above is
equivalent to
\codeblock{(reduce conj \{\} (range 10))}
where \code{reduce} is a fold operation, an operation that iterates over the collection in order to create a return value,
%\emcomment{``fold'' is only understandable for those who know Lisp}
and \code{conj} is the function that
will try to add the integer to the map. During the reduction, the equivalent of
the call that causes the exception is
\codeblock{(conj \{\} 0)}
Past this point, the code that executes is the Java code in Clojure's
implementation, namely the \code{cons} method in the
\code{clojure.lang.APersistentMap} abstract class. After the \code{cons} method
determines that \code{0} is not a valid form of a map entry, it then tries to
turn \code{0} into a sequence. It is at this point that the exception occurs.

Due to the number of factors that inform this error, it
is difficult to derive an appropriate error message. In addition, the layers of
abstraction raise the question of how to assign ``blame'' in the error
message. Referring to the Java code in the implementation would not be very
useful, as it is an implementation detail and usually not directly invoked by the
programmer. Referring to \code{reduce} in the error message also does not make 
sense because it is not \code{reduce} that caught the error in the code;
\code{reduce} was just doing its job. There are thus only two functions that it
makes sense to refer to in the error message: \code{conj} and \code{into}.

There are some reasons why one should refer to  \code{conj}. \code{conj} is the function where the problem actually occurred, and the
documentation for \code{into} implies that \code{into} uses \code{conj}. At the
same time, there are reasons why one should refer to \code{into}. The error
occurred because \code{into} was given arguments that do not work together, and
the code sample that caused the error refers to \code{into}, and not
\code{conj}.

Complicating matters further are the implications this decision has for
the handling of abstractions. If we refer to \code{conj}, we will
break abstractions in the code and expose implementation details when generating
error messages. On the other hand, referring to \code{into} means that
we will be 
trying to find the right separation point between abstractions after the error
occurred. For instance, what if this \code{into} call was part of another
function? In that case, it could be argued that the real issue then lies with
the function that made the bad \code{into} call. But continuing this logic would
lead to always blaming the top-level function that is being run, which would
not constitute useful error reporting.

\section{Conclusions and future work}
%\emcomment{old wording:} There is much \ebcomment{"low-hanging fruit" doesn't seem apt given the sentence about Clojure's hosted nature}  in this area of research that has yet to be addressed. 
Given that our research represents the first systematic attempt to analyze and improve Clojure's error message system, there are still many basic issues to address. While we have addressed and successfully mitigated problems with type casting and invalid argument error reporting, we have yet to develop a way to deal with context-dependent error messages in a useful manner. Clojure's hosted nature makes this problem more difficult, as one must explain errors coming from the host without depending on the context of the host to make sense of them. Future efforts must be spent solving this problem, further improving the error reporting of the Clojure programming language, and developing good basic principles for the improvement of error message usability in general. To this end, we plan to make our error message system available to Clojure users and study the quality of their experiences with it.
%\bgcomment{Any other future work?} 
%\ebcomment{This is Brian's conclusion: "With a few good basic principles and some work, one can improve many of the error messages in a language that has not yet put much thought into the subject." use whichever one, I guess.}

%\emcomment{We should mention that we plan to make our error message system available to Clojure users and study the quality of their experience.}

\bibliographystyle{acm}
\bibliography{mics2011clojure}

\appendix
\section{Exceptions}
\label{app:exceptions}

\subsection{Type errors}
\begin{exceptiontable}
\etrow{adding-maps}
{(+ \{:a 1, :b 2\} 3)}
{\clpam~cannot be cast to \jlnum}
{\cce}
{\code{\{:a 1, :b 2\}} is a map, not a number}
{\cce}
{Cannot use a map (\clpam) as a number (\jlnum)}

\etrow{adding-strings}
{(+ 5 "foo")}
{\jlstring~cannot be cast to \jlnum}
{\cce}
{\code{"foo"} is not a number}
{\cce}
{Cannot use a string (\jlstring) as a number (\jlnum)}

\etrow{calling-numbers}
{(5 3)}
{The code tried to use 5 as a function}
{\cce}
{\jllong~cannot be cast to \clifn}
{\cce}
{Cannot use a number (\jllong) as a function (\clifn)}

\etrow{accidental-builtin-usage}
{(inc num)}
{\code{clojure.core\$num} cannot be cast to \jlnum}
{\cce}
{\code{num} is a function}
{\cce}
{Cannot use a function (\code{clojure.core/num}) as a number (\jlnum)}

\etrow{bad-type}
{(map inc [1 2 :3 4])}
{A keyword is not a number}
{\cce}
{\clkeyword~cannot be cast to \jlnum}
{\cce}
{Cannot use a keyword (\clkeyword) as a number (\jlnum)}

\etrow{int-a-vector}
{(int [1])}
{A vector is not a number}
{\cce}
{\clpv~cannot be cast to \jlchar}
{\cce}
{Cannot use a vector (\clpv) as a number (\jlnum)}
\end{exceptiontable}

\subsection{Invalid arguments}
\begin{exceptiontable}
\etrow{bad-index}
{(nth [1 2 3 4] 6)}
{The index 6 is out of bounds}
{\ioobe}
{}
{\ioobe}
{Index: 6, Size: 4}

\etrow{neg-index-finite}
{(nth [1 2 3] -5)}
{The index -5 is out of bounds}
{\ioobe}
{}
{\ioobe}
{Index: -5, Size: 4}

\etrow{neg-index-infinite}
{(nth (range) -5)}
{The index -5 is out of bounds}
{\ioobe}
{}
{\ioobe}
{Index: -5, Size: unknown}

\etrow{bad-syntax}
{\{:a 1, :b\}}
{There is no value for the key \code{:b}}
{ArrayIndexOutOfBoundsException}
{3}
{\iae}
{Cannot create a map from an odd number of items: 3}

\etrow{comparator-wrong-arity}
{(apply sorted-map-by \#(+ 1 \%) [1 2 3 4])}
{\code{\#(+ 1 \%)} should take two arguments, not one}
{ArityException}
{Wrong number of args (2) passed to: \code{user\$eval16\$fn}}
{\iae}
{Function is not a valid \code{java.util.Comparator}}

\etrow{comparator-bad-return}
{(apply sorted-map-by (constantly "hello") [1 2 3 4])}
{The comparator should return a number, not a string}
{\cce}
{\jlstring~cannot be cast to \jlnum}
{\iae}
{Function is not a valid \code{java.util.Comparator}}
\end{exceptiontable}

\subsection{Context-dependent error messages}
\begin{exceptiontable}
\etrow{into-conj}
{(into \{\} (range 10))}
{\code{into} needs a sequence of pairs, not a sequence of numbers}
{\iae}
{Don't know how to create \code{ISeq} from: \jllong}
{}
{\emph{A new message has not been created yet}}
\end{exceptiontable}
\end{document}
